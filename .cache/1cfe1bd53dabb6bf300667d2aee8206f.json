{"dependencies":[{"name":"graphql","loc":{"line":12,"column":23}},{"name":"graphql/type/introspection","loc":{"line":14,"column":29}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDefinitionState = getDefinitionState;\nexports.getFieldDef = getFieldDef;\nexports.forEachState = forEachState;\nexports.objectValues = objectValues;\nexports.hintList = hintList;\n\nvar _graphql = require('graphql');\n\nvar _introspection = require('graphql/type/introspection');\n\n// Utility for returning the state representing the Definition this token state\n// is within, if any.\nfunction getDefinitionState(tokenState) {\n  var definitionState = void 0;\n\n  forEachState(tokenState, function (state) {\n    switch (state.kind) {\n      case 'Query':\n      case 'ShortQuery':\n      case 'Mutation':\n      case 'Subscription':\n      case 'FragmentDefinition':\n        definitionState = state;\n        break;\n    }\n  });\n\n  return definitionState;\n}\n\n// Gets the field definition given a type and field name\n/**\n *  Copyright (c) Facebook, Inc.\n *  All rights reserved.\n *\n *  This source code is licensed under the license found in the\n *  LICENSE file in the root directory of this source tree.\n *\n *  \n */\n\nfunction getFieldDef(schema, type, fieldName) {\n  if (fieldName === _introspection.SchemaMetaFieldDef.name && schema.getQueryType() === type) {\n    return _introspection.SchemaMetaFieldDef;\n  }\n  if (fieldName === _introspection.TypeMetaFieldDef.name && schema.getQueryType() === type) {\n    return _introspection.TypeMetaFieldDef;\n  }\n  if (fieldName === _introspection.TypeNameMetaFieldDef.name && (0, _graphql.isCompositeType)(type)) {\n    return _introspection.TypeNameMetaFieldDef;\n  }\n  if (type.getFields && typeof type.getFields === 'function') {\n    return type.getFields()[fieldName];\n  }\n\n  return null;\n}\n\n// Utility for iterating through a CodeMirror parse state stack bottom-up.\nfunction forEachState(stack, fn) {\n  var reverseStateStack = [];\n  var state = stack;\n  while (state && state.kind) {\n    reverseStateStack.push(state);\n    state = state.prevState;\n  }\n  for (var i = reverseStateStack.length - 1; i >= 0; i--) {\n    fn(reverseStateStack[i]);\n  }\n}\n\nfunction objectValues(object) {\n  var keys = Object.keys(object);\n  var len = keys.length;\n  var values = new Array(len);\n  for (var i = 0; i < len; ++i) {\n    values[i] = object[keys[i]];\n  }\n  return values;\n}\n\n// Create the expected hint response given a possible list and a token\nfunction hintList(token, list) {\n  return filterAndSortList(list, normalizeText(token.string));\n}\n\n// Given a list of hint entries and currently typed text, sort and filter to\n// provide a concise list.\nfunction filterAndSortList(list, text) {\n  if (!text) {\n    return filterNonEmpty(list, function (entry) {\n      return !entry.isDeprecated;\n    });\n  }\n\n  var byProximity = list.map(function (entry) {\n    return {\n      proximity: getProximity(normalizeText(entry.label), text),\n      entry: entry\n    };\n  });\n\n  var conciseMatches = filterNonEmpty(filterNonEmpty(byProximity, function (pair) {\n    return pair.proximity <= 2;\n  }), function (pair) {\n    return !pair.entry.isDeprecated;\n  });\n\n  var sortedMatches = conciseMatches.sort(function (a, b) {\n    return (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length;\n  });\n\n  return sortedMatches.map(function (pair) {\n    return pair.entry;\n  });\n}\n\n// Filters the array by the predicate, unless it results in an empty array,\n// in which case return the original array.\nfunction filterNonEmpty(array, predicate) {\n  var filtered = array.filter(predicate);\n  return filtered.length === 0 ? array : filtered;\n}\n\nfunction normalizeText(text) {\n  return text.toLowerCase().replace(/\\W/g, '');\n}\n\n// Determine a numeric proximity for a suggestion based on current text.\nfunction getProximity(suggestion, text) {\n  // start with lexical distance\n  var proximity = lexicalDistance(text, suggestion);\n  if (suggestion.length > text.length) {\n    // do not penalize long suggestions.\n    proximity -= suggestion.length - text.length - 1;\n    // penalize suggestions not starting with this phrase\n    proximity += suggestion.indexOf(text) === 0 ? 0 : 0.5;\n  }\n  return proximity;\n}\n\n/**\n * Computes the lexical distance between strings A and B.\n *\n * The \"distance\" between two strings is given by counting the minimum number\n * of edits needed to transform string A into string B. An edit can be an\n * insertion, deletion, or substitution of a single character, or a swap of two\n * adjacent characters.\n *\n * This distance can be useful for detecting typos in input or sorting\n *\n * @param {string} a\n * @param {string} b\n * @return {int} distance in number of edits\n */\nfunction lexicalDistance(a, b) {\n  var i = void 0;\n  var j = void 0;\n  var d = [];\n  var aLength = a.length;\n  var bLength = b.length;\n\n  for (i = 0; i <= aLength; i++) {\n    d[i] = [i];\n  }\n\n  for (j = 1; j <= bLength; j++) {\n    d[0][j] = j;\n  }\n\n  for (i = 1; i <= aLength; i++) {\n    for (j = 1; j <= bLength; j++) {\n      var cost = a[i - 1] === b[j - 1] ? 0 : 1;\n\n      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);\n\n      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {\n        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);\n      }\n    }\n  }\n\n  return d[aLength][bLength];\n}"},"hash":"20173a0c8a13b2d15b4fda28625dd3af"}