{"dependencies":[{"name":"graphql","loc":{"line":19,"column":23}},{"name":"graphql-language-service-parser","loc":{"line":21,"column":44}},{"name":"./autocompleteUtils","loc":{"line":23,"column":33}}],"generated":{"js":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; /**\n                                                                                                                                                                                                                                                                   *  Copyright (c) Facebook, Inc.\n                                                                                                                                                                                                                                                                   *  All rights reserved.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   *  This source code is licensed under the license found in the\n                                                                                                                                                                                                                                                                   *  LICENSE file in the root directory of this source tree.\n                                                                                                                                                                                                                                                                   *\n                                                                                                                                                                                                                                                                   *  \n                                                                                                                                                                                                                                                                   */\n\nexports.getAutocompleteSuggestions = getAutocompleteSuggestions;\n\nvar _graphql = require('graphql');\n\nvar _graphqlLanguageServiceParser = require('graphql-language-service-parser');\n\nvar _autocompleteUtils = require('./autocompleteUtils');\n\n/**\n * Given GraphQLSchema, queryText, and context of the current position within\n * the source text, provide a list of typeahead entries.\n */\nfunction getAutocompleteSuggestions(schema, queryText, cursor, contextToken) {\n  var token = contextToken || getTokenAtPosition(queryText, cursor);\n\n  var state = token.state.kind === 'Invalid' ? token.state.prevState : token.state;\n\n  // relieve flow errors by checking if `state` exists\n  if (!state) {\n    return [];\n  }\n\n  var kind = state.kind;\n  var step = state.step;\n  var typeInfo = getTypeInfo(schema, token.state);\n\n  // Definition kinds\n  if (kind === 'Document') {\n    return (0, _autocompleteUtils.hintList)(token, [{ label: 'query' }, { label: 'mutation' }, { label: 'subscription' }, { label: 'fragment' }, { label: '{' }]);\n  }\n\n  // Field names\n  if (kind === 'SelectionSet' || kind === 'Field' || kind === 'AliasedField') {\n    return getSuggestionsForFieldNames(token, typeInfo, schema);\n  }\n\n  // Argument names\n  if (kind === 'Arguments' || kind === 'Argument' && step === 0) {\n    var argDefs = typeInfo.argDefs;\n    if (argDefs) {\n      return (0, _autocompleteUtils.hintList)(token, argDefs.map(function (argDef) {\n        return {\n          label: argDef.name,\n          detail: String(argDef.type),\n          documentation: argDef.description\n        };\n      }));\n    }\n  }\n\n  // Input Object fields\n  if (kind === 'ObjectValue' || kind === 'ObjectField' && step === 0) {\n    if (typeInfo.objectFieldDefs) {\n      var objectFields = (0, _autocompleteUtils.objectValues)(typeInfo.objectFieldDefs);\n      return (0, _autocompleteUtils.hintList)(token, objectFields.map(function (field) {\n        return {\n          label: field.name,\n          detail: String(field.type),\n          documentation: field.description\n        };\n      }));\n    }\n  }\n\n  // Input values: Enum and Boolean\n  if (kind === 'EnumValue' || kind === 'ListValue' && step === 1 || kind === 'ObjectField' && step === 2 || kind === 'Argument' && step === 2) {\n    return getSuggestionsForInputValues(token, typeInfo);\n  }\n\n  // Fragment type conditions\n  if (kind === 'TypeCondition' && step === 1 || kind === 'NamedType' && state.prevState != null && state.prevState.kind === 'TypeCondition') {\n    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema);\n  }\n\n  // Fragment spread names\n  if (kind === 'FragmentSpread' && step === 1) {\n    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText);\n  }\n\n  // Variable definition types\n  if (kind === 'VariableDefinition' && step === 2 || kind === 'ListType' && step === 1 || kind === 'NamedType' && state.prevState && (state.prevState.kind === 'VariableDefinition' || state.prevState.kind === 'ListType')) {\n    return getSuggestionsForVariableDefinition(token, schema);\n  }\n\n  // Directive names\n  if (kind === 'Directive') {\n    return getSuggestionsForDirective(token, state, schema);\n  }\n\n  return [];\n}\n\n// Helper functions to get suggestions for each kinds\nfunction getSuggestionsForFieldNames(token, typeInfo, schema) {\n  if (typeInfo.parentType) {\n    var parentType = typeInfo.parentType;\n    var fields = parentType.getFields instanceof Function ? (0, _autocompleteUtils.objectValues)(parentType.getFields()) : [];\n    if ((0, _graphql.isAbstractType)(parentType)) {\n      fields.push(_graphql.TypeNameMetaFieldDef);\n    }\n    if (parentType === schema.getQueryType()) {\n      fields.push(_graphql.SchemaMetaFieldDef, _graphql.TypeMetaFieldDef);\n    }\n    return (0, _autocompleteUtils.hintList)(token, fields.map(function (field) {\n      return {\n        label: field.name,\n        detail: String(field.type),\n        documentation: field.description,\n        isDeprecated: field.isDeprecated,\n        deprecationReason: field.deprecationReason\n      };\n    }));\n  }\n  return [];\n}\n\nfunction getSuggestionsForInputValues(token, typeInfo) {\n  var namedInputType = (0, _graphql.getNamedType)(typeInfo.inputType);\n  if (namedInputType instanceof _graphql.GraphQLEnumType) {\n    var values = namedInputType.getValues();\n    return (0, _autocompleteUtils.hintList)(token, values.map(function (value) {\n      return {\n        label: value.name,\n        detail: String(namedInputType),\n        documentation: value.description,\n        isDeprecated: value.isDeprecated,\n        deprecationReason: value.deprecationReason\n      };\n    }));\n  } else if (namedInputType === _graphql.GraphQLBoolean) {\n    return (0, _autocompleteUtils.hintList)(token, [{\n      label: 'true',\n      detail: String(_graphql.GraphQLBoolean),\n      documentation: 'Not false.'\n    }, {\n      label: 'false',\n      detail: String(_graphql.GraphQLBoolean),\n      documentation: 'Not true.'\n    }]);\n  }\n\n  return [];\n}\n\nfunction getSuggestionsForFragmentTypeConditions(token, typeInfo, schema) {\n  var possibleTypes = void 0;\n  if (typeInfo.parentType) {\n    if ((0, _graphql.isAbstractType)(typeInfo.parentType)) {\n      var abstractType = (0, _graphql.assertAbstractType)(typeInfo.parentType);\n      // Collect both the possible Object types as well as the interfaces\n      // they implement.\n      var possibleObjTypes = schema.getPossibleTypes(abstractType);\n      var possibleIfaceMap = Object.create(null);\n      possibleObjTypes.forEach(function (type) {\n        type.getInterfaces().forEach(function (iface) {\n          possibleIfaceMap[iface.name] = iface;\n        });\n      });\n      possibleTypes = possibleObjTypes.concat((0, _autocompleteUtils.objectValues)(possibleIfaceMap));\n    } else {\n      // The parent type is a non-abstract Object type, so the only possible\n      // type that can be used is that same type.\n      possibleTypes = [typeInfo.parentType];\n    }\n  } else {\n    var typeMap = schema.getTypeMap();\n    possibleTypes = (0, _autocompleteUtils.objectValues)(typeMap).filter(_graphql.isCompositeType);\n  }\n  return (0, _autocompleteUtils.hintList)(token, possibleTypes.map(function (type) {\n    var namedType = (0, _graphql.getNamedType)(type);\n    return {\n      label: String(type),\n      documentation: namedType && namedType.description || ''\n    };\n  }));\n}\n\nfunction getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText) {\n  var typeMap = schema.getTypeMap();\n  var defState = (0, _autocompleteUtils.getDefinitionState)(token.state);\n  var fragments = getFragmentDefinitions(queryText);\n\n  // Filter down to only the fragments which may exist here.\n  var relevantFrags = fragments.filter(function (frag) {\n    return (\n      // Only include fragments with known types.\n      typeMap[frag.typeCondition.name.value] &&\n      // Only include fragments which are not cyclic.\n      !(defState && defState.kind === 'FragmentDefinition' && defState.name === frag.name.value) &&\n      // Only include fragments which could possibly be spread here.\n      (0, _graphql.isCompositeType)(typeInfo.parentType) && (0, _graphql.isCompositeType)(typeMap[frag.typeCondition.name.value]) && (0, _graphql.doTypesOverlap)(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value])\n    );\n  });\n\n  return (0, _autocompleteUtils.hintList)(token, relevantFrags.map(function (frag) {\n    return {\n      label: frag.name.value,\n      detail: String(typeMap[frag.typeCondition.name.value]),\n      documentation: 'fragment ' + frag.name.value + ' on ' + frag.typeCondition.name.value\n    };\n  }));\n}\n\nfunction getFragmentDefinitions(queryText) {\n  var fragmentDefs = [];\n  runOnlineParser(queryText, function (_, state) {\n    if (state.kind === 'FragmentDefinition' && state.name && state.type) {\n      fragmentDefs.push({\n        kind: 'FragmentDefinition',\n        name: {\n          kind: 'Name',\n          value: state.name\n        },\n        selectionSet: {\n          kind: 'SelectionSet',\n          selections: []\n        },\n        typeCondition: {\n          kind: 'NamedType',\n          name: {\n            kind: 'Name',\n            value: state.type\n          }\n        }\n      });\n    }\n  });\n\n  return fragmentDefs;\n}\n\nfunction getSuggestionsForVariableDefinition(token, schema) {\n  var inputTypeMap = schema.getTypeMap();\n  var inputTypes = (0, _autocompleteUtils.objectValues)(inputTypeMap).filter(_graphql.isInputType);\n  return (0, _autocompleteUtils.hintList)(token, inputTypes.map(function (type) {\n    return {\n      label: type.name,\n      documentation: type.description\n    };\n  }));\n}\n\nfunction getSuggestionsForDirective(token, state, schema) {\n  if (state.prevState && state.prevState.kind) {\n    var directives = schema.getDirectives().filter(function (directive) {\n      return canUseDirective(state.prevState, directive);\n    });\n    return (0, _autocompleteUtils.hintList)(token, directives.map(function (directive) {\n      return {\n        label: directive.name,\n        documentation: directive.description || ''\n      };\n    }));\n  }\n  return [];\n}\n\nfunction getTokenAtPosition(queryText, cursor) {\n  var styleAtCursor = null;\n  var stateAtCursor = null;\n  var stringAtCursor = null;\n  var token = runOnlineParser(queryText, function (stream, state, style, index) {\n    if (index === cursor.line) {\n      if (stream.getCurrentPosition() >= cursor.character) {\n        styleAtCursor = style;\n        stateAtCursor = _extends({}, state);\n        stringAtCursor = stream.current();\n        return 'BREAK';\n      }\n    }\n  });\n\n  // Return the state/style of parsed token in case those at cursor aren't\n  // available.\n  return {\n    start: token.start,\n    end: token.end,\n    string: stringAtCursor || token.string,\n    state: stateAtCursor || token.state,\n    style: styleAtCursor || token.style\n  };\n}\n\n/**\n * Provides an utility function to parse a given query text and construct a\n * `token` context object.\n * A token context provides useful information about the token/style that\n * CharacterStream currently possesses, as well as the end state and style\n * of the token.\n */\n\n\nfunction runOnlineParser(queryText, callback) {\n  var lines = queryText.split('\\n');\n  var parser = (0, _graphqlLanguageServiceParser.onlineParser)();\n  var state = parser.startState();\n  var style = '';\n\n  var stream = new _graphqlLanguageServiceParser.CharacterStream('');\n\n  for (var i = 0; i < lines.length; i++) {\n    stream = new _graphqlLanguageServiceParser.CharacterStream(lines[i]);\n    while (!stream.eol()) {\n      style = parser.token(stream, state);\n      var code = callback(stream, state, style, i);\n      if (code === 'BREAK') {\n        break;\n      }\n    }\n\n    // Above while loop won't run if there is an empty line.\n    // Run the callback one more time to catch this.\n    callback(stream, state, style, i);\n\n    if (!state.kind) {\n      state = parser.startState();\n    }\n  }\n\n  return {\n    start: stream.getStartOfToken(),\n    end: stream.getCurrentPosition(),\n    string: stream.current(),\n    state: state,\n    style: style\n  };\n}\n\nfunction canUseDirective(state, directive) {\n  if (!state || !state.kind) {\n    return false;\n  }\n  var kind = state.kind;\n  var locations = directive.locations;\n  switch (kind) {\n    case 'Query':\n      return locations.indexOf('QUERY') !== -1;\n    case 'Mutation':\n      return locations.indexOf('MUTATION') !== -1;\n    case 'Subscription':\n      return locations.indexOf('SUBSCRIPTION') !== -1;\n    case 'Field':\n    case 'AliasedField':\n      return locations.indexOf('FIELD') !== -1;\n    case 'FragmentDefinition':\n      return locations.indexOf('FRAGMENT_DEFINITION') !== -1;\n    case 'FragmentSpread':\n      return locations.indexOf('FRAGMENT_SPREAD') !== -1;\n    case 'InlineFragment':\n      return locations.indexOf('INLINE_FRAGMENT') !== -1;\n\n    // Schema Definitions\n    case 'SchemaDef':\n      return locations.indexOf('SCHEMA') !== -1;\n    case 'ScalarDef':\n      return locations.indexOf('SCALAR') !== -1;\n    case 'ObjectTypeDef':\n      return locations.indexOf('OBJECT') !== -1;\n    case 'FieldDef':\n      return locations.indexOf('FIELD_DEFINITION') !== -1;\n    case 'InterfaceDef':\n      return locations.indexOf('INTERFACE') !== -1;\n    case 'UnionDef':\n      return locations.indexOf('UNION') !== -1;\n    case 'EnumDef':\n      return locations.indexOf('ENUM') !== -1;\n    case 'EnumValue':\n      return locations.indexOf('ENUM_VALUE') !== -1;\n    case 'InputDef':\n      return locations.indexOf('INPUT_OBJECT') !== -1;\n    case 'InputValueDef':\n      var prevStateKind = state.prevState && state.prevState.kind;\n      switch (prevStateKind) {\n        case 'ArgumentsDef':\n          return locations.indexOf('ARGUMENT_DEFINITION') !== -1;\n        case 'InputDef':\n          return locations.indexOf('INPUT_FIELD_DEFINITION') !== -1;\n      }\n  }\n  return false;\n}\n\n// Utility for collecting rich type information given any token's state\n// from the graphql-mode parser.\nfunction getTypeInfo(schema, tokenState) {\n  var argDef = void 0;\n  var argDefs = void 0;\n  var directiveDef = void 0;\n  var enumValue = void 0;\n  var fieldDef = void 0;\n  var inputType = void 0;\n  var objectFieldDefs = void 0;\n  var parentType = void 0;\n  var type = void 0;\n\n  (0, _autocompleteUtils.forEachState)(tokenState, function (state) {\n    switch (state.kind) {\n      case 'Query':\n      case 'ShortQuery':\n        type = schema.getQueryType();\n        break;\n      case 'Mutation':\n        type = schema.getMutationType();\n        break;\n      case 'Subscription':\n        type = schema.getSubscriptionType();\n        break;\n      case 'InlineFragment':\n      case 'FragmentDefinition':\n        if (state.type) {\n          type = schema.getType(state.type);\n        }\n        break;\n      case 'Field':\n      case 'AliasedField':\n        if (!type || !state.name) {\n          fieldDef = null;\n        } else {\n          fieldDef = parentType ? (0, _autocompleteUtils.getFieldDef)(schema, parentType, state.name) : null;\n          type = fieldDef ? fieldDef.type : null;\n        }\n        break;\n      case 'SelectionSet':\n        parentType = (0, _graphql.getNamedType)(type);\n        break;\n      case 'Directive':\n        directiveDef = state.name ? schema.getDirective(state.name) : null;\n        break;\n      case 'Arguments':\n        if (!state.prevState) {\n          argDefs = null;\n        } else {\n          switch (state.prevState.kind) {\n            case 'Field':\n              argDefs = fieldDef && fieldDef.args;\n              break;\n            case 'Directive':\n              argDefs = directiveDef && directiveDef.args;\n              break;\n            case 'AliasedField':\n              var name = state.prevState && state.prevState.name;\n              if (!name) {\n                argDefs = null;\n                break;\n              }\n              var field = parentType ? (0, _autocompleteUtils.getFieldDef)(schema, parentType, name) : null;\n              if (!field) {\n                argDefs = null;\n                break;\n              }\n              argDefs = field.args;\n              break;\n            default:\n              argDefs = null;\n              break;\n          }\n        }\n        break;\n      case 'Argument':\n        if (argDefs) {\n          for (var i = 0; i < argDefs.length; i++) {\n            if (argDefs[i].name === state.name) {\n              argDef = argDefs[i];\n              break;\n            }\n          }\n        }\n        inputType = argDef && argDef.type;\n        break;\n      case 'EnumValue':\n        var enumType = (0, _graphql.getNamedType)(inputType);\n        enumValue = enumType instanceof _graphql.GraphQLEnumType ? find(enumType.getValues(), function (val) {\n          return val.value === state.name;\n        }) : null;\n        break;\n      case 'ListValue':\n        var nullableType = (0, _graphql.getNullableType)(inputType);\n        inputType = nullableType instanceof _graphql.GraphQLList ? nullableType.ofType : null;\n        break;\n      case 'ObjectValue':\n        var objectType = (0, _graphql.getNamedType)(inputType);\n        objectFieldDefs = objectType instanceof _graphql.GraphQLInputObjectType ? objectType.getFields() : null;\n        break;\n      case 'ObjectField':\n        var objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;\n        inputType = objectField && objectField.type;\n        break;\n      case 'NamedType':\n        if (state.name) {\n          type = schema.getType(state.name);\n        }\n        break;\n    }\n  });\n\n  return {\n    argDef: argDef,\n    argDefs: argDefs,\n    directiveDef: directiveDef,\n    enumValue: enumValue,\n    fieldDef: fieldDef,\n    inputType: inputType,\n    objectFieldDefs: objectFieldDefs,\n    parentType: parentType,\n    type: type\n  };\n}\n\n// Returns the first item in the array which causes predicate to return truthy.\nfunction find(array, predicate) {\n  for (var i = 0; i < array.length; i++) {\n    if (predicate(array[i])) {\n      return array[i];\n    }\n  }\n  return null;\n}"},"hash":"c28f683e18dfb1bf37a1030f5af47a96"}